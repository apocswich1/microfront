import { Injectable, Inject } from '@angular/core';
import { ɵBrowserPlatformLocation, PlatformLocation, DOCUMENT, } from '@angular/common';
import * as i0 from "@angular/core";
export class SingleSpaPlatformLocation extends ɵBrowserPlatformLocation {
    constructor() {
        super(...arguments);
        // This is a simple marker that helps us to ignore PopStateEvents
        // that was not dispatched by the browser.
        this.skipNextPopState = false;
        this.source = 'Window.addEventListener:popstate';
    }
    pushState(state, title, url) {
        this.skipNextPopState = true;
        super.pushState(state, title, url);
    }
    replaceState(state, title, url) {
        this.skipNextPopState = true;
        super.replaceState(state, title, url);
    }
    onPopState(fn) {
        // `Zone.current` will reference the zone that serves as an execution context
        // to some specific application, especially when `onPopState` is called.
        const zone = Zone.current;
        // Wrap any event listener into zone that is specific to some application.
        // The main issue is `back/forward` buttons of browsers, because they invoke
        // `history.back|forward` which dispatch `popstate` event. Since `single-spa`
        // overrides `history.replaceState` Angular's zone cannot intercept this event.
        // Only the root zone is able to intercept all events.
        // See https://github.com/single-spa/single-spa-angular/issues/94 for more details
        fn = zone.wrap(fn, this.source);
        const onPopStateListener = (event) => {
            // The `LocationChangeEvent` doesn't have the `singleSpa` property, since it's added
            // by `single-spa` starting from `5.4` version. We need this check because we want
            // to skip "unnatural" PopStateEvents, the one caused by `single-spa`.
            const popStateEventWasDispatchedBySingleSpa = !!event
                .singleSpa;
            if (this.skipNextPopState && popStateEventWasDispatchedBySingleSpa) {
                this.skipNextPopState = false;
            }
            else {
                fn(event);
            }
        };
        return super.onPopState(onPopStateListener);
    }
}
/** @nocollapse */ /** @nocollapse */ SingleSpaPlatformLocation.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: SingleSpaPlatformLocation, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ /** @nocollapse */ SingleSpaPlatformLocation.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: SingleSpaPlatformLocation });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: SingleSpaPlatformLocation, decorators: [{
            type: Injectable
        }] });
/**
 * The `PlatformLocation` class is an "injectee" of the `PathLocationStrategy`,
 * which creates `Subject` internally for listening on `popstate` events. We want
 * to provide this class in the most top injector that's used during bootstrapping.
 */
export function getSingleSpaExtraProviders() {
    return [
        {
            provide: SingleSpaPlatformLocation,
            deps: [[new Inject(DOCUMENT)]],
        },
        {
            provide: PlatformLocation,
            useExisting: SingleSpaPlatformLocation,
        },
    ];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0cmEtcHJvdmlkZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGlicy9zaW5nbGUtc3BhLWFuZ3VsYXIvc3JjL2V4dHJhLXByb3ZpZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFrQixNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUNMLHdCQUF3QixFQUN4QixnQkFBZ0IsRUFHaEIsUUFBUSxHQUNULE1BQU0saUJBQWlCLENBQUM7O0FBS3pCLE1BQU0sT0FBTyx5QkFBMEIsU0FBUSx3QkFBd0I7SUFEdkU7O1FBRUUsaUVBQWlFO1FBQ2pFLDBDQUEwQztRQUNsQyxxQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFFaEIsV0FBTSxHQUFHLGtDQUFrQyxDQUFDO0tBeUM5RDtJQXZDQyxTQUFTLENBQUMsS0FBVSxFQUFFLEtBQWEsRUFBRSxHQUFXO1FBQzlDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFDN0IsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCxZQUFZLENBQUMsS0FBVSxFQUFFLEtBQWEsRUFBRSxHQUFXO1FBQ2pELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFDN0IsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRCxVQUFVLENBQUMsRUFBMEI7UUFDbkMsNkVBQTZFO1FBQzdFLHdFQUF3RTtRQUN4RSxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBRTFCLDBFQUEwRTtRQUMxRSw0RUFBNEU7UUFDNUUsNkVBQTZFO1FBQzdFLCtFQUErRTtRQUMvRSxzREFBc0Q7UUFDdEQsa0ZBQWtGO1FBQ2xGLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFaEMsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLEtBQTBCLEVBQUUsRUFBRTtZQUN4RCxvRkFBb0Y7WUFDcEYsa0ZBQWtGO1lBQ2xGLHNFQUFzRTtZQUN0RSxNQUFNLHFDQUFxQyxHQUFHLENBQUMsQ0FBRSxLQUEyQztpQkFDekYsU0FBUyxDQUFDO1lBRWIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLElBQUkscUNBQXFDLEVBQUU7Z0JBQ2xFLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7YUFDL0I7aUJBQU07Z0JBQ0wsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ1g7UUFDSCxDQUFDLENBQUM7UUFFRixPQUFPLEtBQUssQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUM5QyxDQUFDOzs0SkE3Q1UseUJBQXlCO2dLQUF6Qix5QkFBeUI7MkZBQXpCLHlCQUF5QjtrQkFEckMsVUFBVTs7QUFpRFg7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSwwQkFBMEI7SUFDeEMsT0FBTztRQUNMO1lBQ0UsT0FBTyxFQUFFLHlCQUF5QjtZQUNsQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7U0FDL0I7UUFDRDtZQUNFLE9BQU8sRUFBRSxnQkFBZ0I7WUFDekIsV0FBVyxFQUFFLHlCQUF5QjtTQUN2QztLQUNGLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgU3RhdGljUHJvdmlkZXIsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgybVCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbixcbiAgUGxhdGZvcm1Mb2NhdGlvbixcbiAgTG9jYXRpb25DaGFuZ2VFdmVudCxcbiAgTG9jYXRpb25DaGFuZ2VMaXN0ZW5lcixcbiAgRE9DVU1FTlQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmRlY2xhcmUgY29uc3QgWm9uZTogYW55O1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbiBleHRlbmRzIMm1QnJvd3NlclBsYXRmb3JtTG9jYXRpb24ge1xuICAvLyBUaGlzIGlzIGEgc2ltcGxlIG1hcmtlciB0aGF0IGhlbHBzIHVzIHRvIGlnbm9yZSBQb3BTdGF0ZUV2ZW50c1xuICAvLyB0aGF0IHdhcyBub3QgZGlzcGF0Y2hlZCBieSB0aGUgYnJvd3Nlci5cbiAgcHJpdmF0ZSBza2lwTmV4dFBvcFN0YXRlID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBzb3VyY2UgPSAnV2luZG93LmFkZEV2ZW50TGlzdGVuZXI6cG9wc3RhdGUnO1xuXG4gIHB1c2hTdGF0ZShzdGF0ZTogYW55LCB0aXRsZTogc3RyaW5nLCB1cmw6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc2tpcE5leHRQb3BTdGF0ZSA9IHRydWU7XG4gICAgc3VwZXIucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcbiAgfVxuXG4gIHJlcGxhY2VTdGF0ZShzdGF0ZTogYW55LCB0aXRsZTogc3RyaW5nLCB1cmw6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc2tpcE5leHRQb3BTdGF0ZSA9IHRydWU7XG4gICAgc3VwZXIucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcbiAgfVxuXG4gIG9uUG9wU3RhdGUoZm46IExvY2F0aW9uQ2hhbmdlTGlzdGVuZXIpOiBWb2lkRnVuY3Rpb24ge1xuICAgIC8vIGBab25lLmN1cnJlbnRgIHdpbGwgcmVmZXJlbmNlIHRoZSB6b25lIHRoYXQgc2VydmVzIGFzIGFuIGV4ZWN1dGlvbiBjb250ZXh0XG4gICAgLy8gdG8gc29tZSBzcGVjaWZpYyBhcHBsaWNhdGlvbiwgZXNwZWNpYWxseSB3aGVuIGBvblBvcFN0YXRlYCBpcyBjYWxsZWQuXG4gICAgY29uc3Qgem9uZSA9IFpvbmUuY3VycmVudDtcblxuICAgIC8vIFdyYXAgYW55IGV2ZW50IGxpc3RlbmVyIGludG8gem9uZSB0aGF0IGlzIHNwZWNpZmljIHRvIHNvbWUgYXBwbGljYXRpb24uXG4gICAgLy8gVGhlIG1haW4gaXNzdWUgaXMgYGJhY2svZm9yd2FyZGAgYnV0dG9ucyBvZiBicm93c2VycywgYmVjYXVzZSB0aGV5IGludm9rZVxuICAgIC8vIGBoaXN0b3J5LmJhY2t8Zm9yd2FyZGAgd2hpY2ggZGlzcGF0Y2ggYHBvcHN0YXRlYCBldmVudC4gU2luY2UgYHNpbmdsZS1zcGFgXG4gICAgLy8gb3ZlcnJpZGVzIGBoaXN0b3J5LnJlcGxhY2VTdGF0ZWAgQW5ndWxhcidzIHpvbmUgY2Fubm90IGludGVyY2VwdCB0aGlzIGV2ZW50LlxuICAgIC8vIE9ubHkgdGhlIHJvb3Qgem9uZSBpcyBhYmxlIHRvIGludGVyY2VwdCBhbGwgZXZlbnRzLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc2luZ2xlLXNwYS9zaW5nbGUtc3BhLWFuZ3VsYXIvaXNzdWVzLzk0IGZvciBtb3JlIGRldGFpbHNcbiAgICBmbiA9IHpvbmUud3JhcChmbiwgdGhpcy5zb3VyY2UpO1xuXG4gICAgY29uc3Qgb25Qb3BTdGF0ZUxpc3RlbmVyID0gKGV2ZW50OiBMb2NhdGlvbkNoYW5nZUV2ZW50KSA9PiB7XG4gICAgICAvLyBUaGUgYExvY2F0aW9uQ2hhbmdlRXZlbnRgIGRvZXNuJ3QgaGF2ZSB0aGUgYHNpbmdsZVNwYWAgcHJvcGVydHksIHNpbmNlIGl0J3MgYWRkZWRcbiAgICAgIC8vIGJ5IGBzaW5nbGUtc3BhYCBzdGFydGluZyBmcm9tIGA1LjRgIHZlcnNpb24uIFdlIG5lZWQgdGhpcyBjaGVjayBiZWNhdXNlIHdlIHdhbnRcbiAgICAgIC8vIHRvIHNraXAgXCJ1bm5hdHVyYWxcIiBQb3BTdGF0ZUV2ZW50cywgdGhlIG9uZSBjYXVzZWQgYnkgYHNpbmdsZS1zcGFgLlxuICAgICAgY29uc3QgcG9wU3RhdGVFdmVudFdhc0Rpc3BhdGNoZWRCeVNpbmdsZVNwYSA9ICEhKGV2ZW50IGFzIHVua25vd24gYXMgeyBzaW5nbGVTcGE6IGJvb2xlYW4gfSlcbiAgICAgICAgLnNpbmdsZVNwYTtcblxuICAgICAgaWYgKHRoaXMuc2tpcE5leHRQb3BTdGF0ZSAmJiBwb3BTdGF0ZUV2ZW50V2FzRGlzcGF0Y2hlZEJ5U2luZ2xlU3BhKSB7XG4gICAgICAgIHRoaXMuc2tpcE5leHRQb3BTdGF0ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4oZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc3VwZXIub25Qb3BTdGF0ZShvblBvcFN0YXRlTGlzdGVuZXIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGBQbGF0Zm9ybUxvY2F0aW9uYCBjbGFzcyBpcyBhbiBcImluamVjdGVlXCIgb2YgdGhlIGBQYXRoTG9jYXRpb25TdHJhdGVneWAsXG4gKiB3aGljaCBjcmVhdGVzIGBTdWJqZWN0YCBpbnRlcm5hbGx5IGZvciBsaXN0ZW5pbmcgb24gYHBvcHN0YXRlYCBldmVudHMuIFdlIHdhbnRcbiAqIHRvIHByb3ZpZGUgdGhpcyBjbGFzcyBpbiB0aGUgbW9zdCB0b3AgaW5qZWN0b3IgdGhhdCdzIHVzZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaW5nbGVTcGFFeHRyYVByb3ZpZGVycygpOiBTdGF0aWNQcm92aWRlcltdIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBTaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uLFxuICAgICAgZGVwczogW1tuZXcgSW5qZWN0KERPQ1VNRU5UKV1dLFxuICAgIH0sXG4gICAge1xuICAgICAgcHJvdmlkZTogUGxhdGZvcm1Mb2NhdGlvbixcbiAgICAgIHVzZUV4aXN0aW5nOiBTaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uLFxuICAgIH0sXG4gIF07XG59XG4iXX0=
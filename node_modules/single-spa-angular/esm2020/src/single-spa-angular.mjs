import { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';
import { SingleSpaPlatformLocation } from './extra-providers';
const defaultOptions = {
    // Required options that will be set by the library consumer.
    NgZone: null,
    bootstrapFunction: null,
    template: null,
    // Optional options
    Router: undefined,
    domElementGetter: undefined,
    updateFunction: () => Promise.resolve(),
    bootstrappedModule: null,
};
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
export function singleSpaAngular(userOptions) {
    if (NG_DEV_MODE && typeof userOptions !== 'object') {
        throw Error('single-spa-angular requires a configuration object');
    }
    const options = {
        ...defaultOptions,
        ...userOptions,
    };
    if (NG_DEV_MODE && typeof options.bootstrapFunction !== 'function') {
        throw Error('single-spa-angular must be passed an options.bootstrapFunction');
    }
    if (NG_DEV_MODE && typeof options.template !== 'string') {
        throw Error('single-spa-angular must be passed options.template string');
    }
    if (NG_DEV_MODE && !options.NgZone) {
        throw Error(`single-spa-angular must be passed the NgZone option`);
    }
    if (NG_DEV_MODE && options.Router && !options.NavigationStart) {
        // We call `console.warn` except of throwing `new Error()` since this will not
        // be a breaking change.
        console.warn(`single-spa-angular must be passed the NavigationStart option`);
    }
    return {
        bootstrap: bootstrap.bind(null, options),
        mount: mount.bind(null, options),
        unmount: unmount.bind(null, options),
        update: options.updateFunction,
    };
}
async function bootstrap(options, props) {
    // Angular provides an opportunity to develop `zone-less` application, where developers
    // have to trigger change detection manually.
    // See https://angular.io/guide/zone#noopzone
    if (options.NgZone === 'noop') {
        return;
    }
    // In order for multiple Angular apps to work concurrently on a page, they each need a unique identifier.
    options.zoneIdentifier = `single-spa-angular:${props.name || props.appName}`;
    // This is a hack, since NgZone doesn't allow you to configure the property that identifies your zone.
    // See https://github.com/PlaceMe-SAS/single-spa-angular-cli/issues/33,
    // https://github.com/single-spa/single-spa-angular/issues/47,
    // https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L144,
    // and https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L257
    options.NgZone.isInAngularZone = () => {
        // @ts-ignore
        return window.Zone.current._properties[options.zoneIdentifier] === true;
    };
    options.routingEventListener = () => {
        options.bootstrappedNgZone.run(() => {
            // See https://github.com/single-spa/single-spa-angular/issues/86
            // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work
            // unless we tell Zone that something happened
        });
    };
}
async function mount(options, props) {
    getContainerElementAndSetTemplate(options, props);
    const bootstrapPromise = options.bootstrapFunction(props);
    if (NG_DEV_MODE && !(bootstrapPromise instanceof Promise)) {
        throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);
    }
    const module = await bootstrapPromise;
    if (NG_DEV_MODE) {
        if (!module || typeof module.destroy !== 'function') {
            throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);
        }
    }
    const singleSpaPlatformLocation = module.injector.get(SingleSpaPlatformLocation, null);
    const ngZoneEnabled = options.NgZone !== 'noop';
    // The user has to provide `BrowserPlatformLocation` only if his application uses routing.
    // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.
    // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use
    // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.
    if (NG_DEV_MODE && ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {
        throw new Error(`
      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?
    `);
    }
    const bootstrappedOptions = options;
    if (ngZoneEnabled) {
        const ngZone = module.injector.get(options.NgZone);
        const zoneIdentifier = bootstrappedOptions.zoneIdentifier;
        // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`
        // function was not called.
        if (singleSpaPlatformLocation !== null) {
            skipLocationChangeOnNonImperativeRoutingTriggers(module, options);
        }
        bootstrappedOptions.bootstrappedNgZone = ngZone;
        bootstrappedOptions.bootstrappedNgZone['_inner']._properties[zoneIdentifier] = true;
        window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);
    }
    bootstrappedOptions.bootstrappedModule = module;
    return module;
}
function unmount(options) {
    return Promise.resolve().then(() => {
        if (options.routingEventListener) {
            window.removeEventListener('single-spa:routing-event', options.routingEventListener);
        }
        options.bootstrappedModule.destroy();
        options.bootstrappedModule = null;
    });
}
function skipLocationChangeOnNonImperativeRoutingTriggers(module, options) {
    if (!options.NavigationStart) {
        // As discussed we don't do anything right now if the developer doesn't provide
        // `options.NavigationStart` since this might be a breaking change.
        return;
    }
    const router = module.injector.get(options.Router);
    const subscription = router.events.subscribe((event) => {
        if (event instanceof options.NavigationStart) {
            const currentNavigation = router.getCurrentNavigation();
            // This listener will be set up for each Angular application
            // that has routing capabilities.
            // We set `skipLocationChange` for each non-imperative navigation,
            // Angular router checks under the hood if it has to change
            // the browser URL or not.
            // If `skipLocationChange` is truthy then Angular router will not call
            // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.
            if (currentNavigation.trigger !== 'imperative') {
                currentNavigation.extras.skipLocationChange = true;
                currentNavigation.extras.replaceUrl = false;
            }
        }
    });
    module.onDestroy(() => {
        subscription.unsubscribe();
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2luZ2xlLXNwYS1hbmd1bGFyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGlicy9zaW5nbGUtc3BhLWFuZ3VsYXIvc3JjL3NpbmdsZS1zcGEtYW5ndWxhci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxPQUFPLEVBQUUsaUNBQWlDLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUVqRixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUc5RCxNQUFNLGNBQWMsR0FBRztJQUNyQiw2REFBNkQ7SUFDN0QsTUFBTSxFQUFFLElBQUs7SUFDYixpQkFBaUIsRUFBRSxJQUFLO0lBQ3hCLFFBQVEsRUFBRSxJQUFLO0lBQ2YsbUJBQW1CO0lBQ25CLE1BQU0sRUFBRSxTQUFTO0lBQ2pCLGdCQUFnQixFQUFFLFNBQVM7SUFDM0IsY0FBYyxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7SUFDdkMsa0JBQWtCLEVBQUUsSUFBSTtDQUN6QixDQUFDO0FBTUYsTUFBTSxXQUFXLEdBQUcsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQztBQUVsRSxNQUFNLFVBQVUsZ0JBQWdCLENBQUksV0FBdUM7SUFDekUsSUFBSSxXQUFXLElBQUksT0FBTyxXQUFXLEtBQUssUUFBUSxFQUFFO1FBQ2xELE1BQU0sS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7S0FDbkU7SUFFRCxNQUFNLE9BQU8sR0FBNEI7UUFDdkMsR0FBRyxjQUFjO1FBQ2pCLEdBQUcsV0FBVztLQUNmLENBQUM7SUFFRixJQUFJLFdBQVcsSUFBSSxPQUFPLE9BQU8sQ0FBQyxpQkFBaUIsS0FBSyxVQUFVLEVBQUU7UUFDbEUsTUFBTSxLQUFLLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztLQUMvRTtJQUVELElBQUksV0FBVyxJQUFJLE9BQU8sT0FBTyxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUU7UUFDdkQsTUFBTSxLQUFLLENBQUMsMkRBQTJELENBQUMsQ0FBQztLQUMxRTtJQUVELElBQUksV0FBVyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRTtRQUNsQyxNQUFNLEtBQUssQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO0tBQ3BFO0lBRUQsSUFBSSxXQUFXLElBQUksT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUU7UUFDN0QsOEVBQThFO1FBQzlFLHdCQUF3QjtRQUN4QixPQUFPLENBQUMsSUFBSSxDQUFDLDhEQUE4RCxDQUFDLENBQUM7S0FDOUU7SUFFRCxPQUFPO1FBQ0wsU0FBUyxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQThDLENBQUM7UUFDL0UsS0FBSyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQztRQUNoQyxPQUFPLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBOEMsQ0FBQztRQUMzRSxNQUFNLEVBQUUsT0FBTyxDQUFDLGNBQWM7S0FDL0IsQ0FBQztBQUNKLENBQUM7QUFFRCxLQUFLLFVBQVUsU0FBUyxDQUFDLE9BQTRDLEVBQUUsS0FBVTtJQUMvRSx1RkFBdUY7SUFDdkYsNkNBQTZDO0lBQzdDLDZDQUE2QztJQUM3QyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssTUFBTSxFQUFFO1FBQzdCLE9BQU87S0FDUjtJQUVELHlHQUF5RztJQUN6RyxPQUFPLENBQUMsY0FBYyxHQUFHLHNCQUFzQixLQUFLLENBQUMsSUFBSSxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUU3RSxzR0FBc0c7SUFDdEcsdUVBQXVFO0lBQ3ZFLDhEQUE4RDtJQUM5RCwySEFBMkg7SUFDM0gsOEhBQThIO0lBQzlILE9BQU8sQ0FBQyxNQUFNLENBQUMsZUFBZSxHQUFHLEdBQUcsRUFBRTtRQUNwQyxhQUFhO1FBQ2IsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxLQUFLLElBQUksQ0FBQztJQUMxRSxDQUFDLENBQUM7SUFFRixPQUFPLENBQUMsb0JBQW9CLEdBQUcsR0FBRyxFQUFFO1FBQ2xDLE9BQU8sQ0FBQyxrQkFBbUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFO1lBQ25DLGlFQUFpRTtZQUNqRSxtR0FBbUc7WUFDbkcsOENBQThDO1FBQ2hELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVELEtBQUssVUFBVSxLQUFLLENBQUMsT0FBZ0MsRUFBRSxLQUFVO0lBQy9ELGlDQUFpQyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUVsRCxNQUFNLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUUxRCxJQUFJLFdBQVcsSUFBSSxDQUFDLENBQUMsZ0JBQWdCLFlBQVksT0FBTyxDQUFDLEVBQUU7UUFDekQsTUFBTSxLQUFLLENBQ1Qsb0dBQW9HLE9BQU8sZ0JBQWdCLHlCQUF5QixDQUNySixDQUFDO0tBQ0g7SUFFRCxNQUFNLE1BQU0sR0FBcUIsTUFBTSxnQkFBZ0IsQ0FBQztJQUV4RCxJQUFJLFdBQVcsRUFBRTtRQUNmLElBQUksQ0FBQyxNQUFNLElBQUksT0FBTyxNQUFNLENBQUMsT0FBTyxLQUFLLFVBQVUsRUFBRTtZQUNuRCxNQUFNLEtBQUssQ0FDVCwyTEFBMkwsQ0FDNUwsQ0FBQztTQUNIO0tBQ0Y7SUFFRCxNQUFNLHlCQUF5QixHQUFxQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FDckYseUJBQXlCLEVBQ3pCLElBQUksQ0FDTCxDQUFDO0lBRUYsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLE1BQU0sS0FBSyxNQUFNLENBQUM7SUFFaEQsMEZBQTBGO0lBQzFGLHNHQUFzRztJQUN0Ryw2RkFBNkY7SUFDN0YsMkVBQTJFO0lBQzNFLElBQUksV0FBVyxJQUFJLGFBQWEsSUFBSSxPQUFPLENBQUMsTUFBTSxJQUFJLHlCQUF5QixLQUFLLElBQUksRUFBRTtRQUN4RixNQUFNLElBQUksS0FBSyxDQUFDOztLQUVmLENBQUMsQ0FBQztLQUNKO0lBRUQsTUFBTSxtQkFBbUIsR0FBRyxPQUE4QyxDQUFDO0lBRTNFLElBQUksYUFBYSxFQUFFO1FBQ2pCLE1BQU0sTUFBTSxHQUFXLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMzRCxNQUFNLGNBQWMsR0FBVyxtQkFBbUIsQ0FBQyxjQUFlLENBQUM7UUFFbkUsMEZBQTBGO1FBQzFGLDJCQUEyQjtRQUMzQixJQUFJLHlCQUF5QixLQUFLLElBQUksRUFBRTtZQUN0QyxnREFBZ0QsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDbkU7UUFFRCxtQkFBbUIsQ0FBQyxrQkFBa0IsR0FBRyxNQUFNLENBQUM7UUFDaEQsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUNwRixNQUFNLENBQUMsZ0JBQWdCLENBQUMsMEJBQTBCLEVBQUUsbUJBQW1CLENBQUMsb0JBQXFCLENBQUMsQ0FBQztLQUNoRztJQUVELG1CQUFtQixDQUFDLGtCQUFrQixHQUFHLE1BQU0sQ0FBQztJQUNoRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQsU0FBUyxPQUFPLENBQUMsT0FBNEM7SUFDM0QsT0FBTyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNqQyxJQUFJLE9BQU8sQ0FBQyxvQkFBb0IsRUFBRTtZQUNoQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsMEJBQTBCLEVBQUUsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7U0FDdEY7UUFFRCxPQUFPLENBQUMsa0JBQW1CLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEMsT0FBTyxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQztJQUNwQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxTQUFTLGdEQUFnRCxDQUN2RCxNQUF3QixFQUN4QixPQUFnQztJQUVoQyxJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRTtRQUM1QiwrRUFBK0U7UUFDL0UsbUVBQW1FO1FBQ25FLE9BQU87S0FDUjtJQUVELE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNuRCxNQUFNLFlBQVksR0FBaUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFVLEVBQUUsRUFBRTtRQUN4RSxJQUFJLEtBQUssWUFBWSxPQUFPLENBQUMsZUFBZ0IsRUFBRTtZQUM3QyxNQUFNLGlCQUFpQixHQUFHLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1lBQ3hELDREQUE0RDtZQUM1RCxpQ0FBaUM7WUFDakMsa0VBQWtFO1lBQ2xFLDJEQUEyRDtZQUMzRCwwQkFBMEI7WUFDMUIsc0VBQXNFO1lBQ3RFLDBGQUEwRjtZQUMxRixJQUFJLGlCQUFpQixDQUFDLE9BQU8sS0FBSyxZQUFZLEVBQUU7Z0JBQzlDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUM7Z0JBQ25ELGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO2FBQzdDO1NBQ0Y7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO1FBQ3BCLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM3QixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ01vZHVsZVJlZiwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IExpZmVDeWNsZXMgfSBmcm9tICdzaW5nbGUtc3BhJztcbmltcG9ydCB7IGdldENvbnRhaW5lckVsZW1lbnRBbmRTZXRUZW1wbGF0ZSB9IGZyb20gJ3NpbmdsZS1zcGEtYW5ndWxhci9pbnRlcm5hbHMnO1xuXG5pbXBvcnQgeyBTaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uIH0gZnJvbSAnLi9leHRyYS1wcm92aWRlcnMnO1xuaW1wb3J0IHsgU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMsIEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAvLyBSZXF1aXJlZCBvcHRpb25zIHRoYXQgd2lsbCBiZSBzZXQgYnkgdGhlIGxpYnJhcnkgY29uc3VtZXIuXG4gIE5nWm9uZTogbnVsbCEsXG4gIGJvb3RzdHJhcEZ1bmN0aW9uOiBudWxsISxcbiAgdGVtcGxhdGU6IG51bGwhLFxuICAvLyBPcHRpb25hbCBvcHRpb25zXG4gIFJvdXRlcjogdW5kZWZpbmVkLFxuICBkb21FbGVtZW50R2V0dGVyOiB1bmRlZmluZWQsIC8vIG9ubHkgb3B0aW9uYWwgaWYgeW91IHByb3ZpZGUgYSBkb21FbGVtZW50R2V0dGVyIGFzIGEgY3VzdG9tIHByb3BcbiAgdXBkYXRlRnVuY3Rpb246ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxuICBib290c3RyYXBwZWRNb2R1bGU6IG51bGwsXG59O1xuXG4vLyBUaGlzIHdpbGwgYmUgcHJvdmlkZWQgdGhyb3VnaCBUZXJzZXIgZ2xvYmFsIGRlZmluaXRpb25zIGJ5IEFuZ3VsYXIgQ0xJLiBUaGlzIHdpbGxcbi8vIGhlbHAgdG8gdHJlZS1zaGFrZSBhd2F5IHRoZSBjb2RlIHVubmVlZGVkIGZvciBwcm9kdWN0aW9uIGJ1bmRsZXMuXG5kZWNsYXJlIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcblxuY29uc3QgTkdfREVWX01PREUgPSB0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGVTcGFBbmd1bGFyPFQ+KHVzZXJPcHRpb25zOiBTaW5nbGVTcGFBbmd1bGFyT3B0aW9uczxUPik6IExpZmVDeWNsZXM8VD4ge1xuICBpZiAoTkdfREVWX01PREUgJiYgdHlwZW9mIHVzZXJPcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IEVycm9yKCdzaW5nbGUtc3BhLWFuZ3VsYXIgcmVxdWlyZXMgYSBjb25maWd1cmF0aW9uIG9iamVjdCcpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9uczogU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4udXNlck9wdGlvbnMsXG4gIH07XG5cbiAgaWYgKE5HX0RFVl9NT0RFICYmIHR5cGVvZiBvcHRpb25zLmJvb3RzdHJhcEZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgRXJyb3IoJ3NpbmdsZS1zcGEtYW5ndWxhciBtdXN0IGJlIHBhc3NlZCBhbiBvcHRpb25zLmJvb3RzdHJhcEZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoTkdfREVWX01PREUgJiYgdHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgRXJyb3IoJ3NpbmdsZS1zcGEtYW5ndWxhciBtdXN0IGJlIHBhc3NlZCBvcHRpb25zLnRlbXBsYXRlIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKE5HX0RFVl9NT0RFICYmICFvcHRpb25zLk5nWm9uZSkge1xuICAgIHRocm93IEVycm9yKGBzaW5nbGUtc3BhLWFuZ3VsYXIgbXVzdCBiZSBwYXNzZWQgdGhlIE5nWm9uZSBvcHRpb25gKTtcbiAgfVxuXG4gIGlmIChOR19ERVZfTU9ERSAmJiBvcHRpb25zLlJvdXRlciAmJiAhb3B0aW9ucy5OYXZpZ2F0aW9uU3RhcnQpIHtcbiAgICAvLyBXZSBjYWxsIGBjb25zb2xlLndhcm5gIGV4Y2VwdCBvZiB0aHJvd2luZyBgbmV3IEVycm9yKClgIHNpbmNlIHRoaXMgd2lsbCBub3RcbiAgICAvLyBiZSBhIGJyZWFraW5nIGNoYW5nZS5cbiAgICBjb25zb2xlLndhcm4oYHNpbmdsZS1zcGEtYW5ndWxhciBtdXN0IGJlIHBhc3NlZCB0aGUgTmF2aWdhdGlvblN0YXJ0IG9wdGlvbmApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBib290c3RyYXA6IGJvb3RzdHJhcC5iaW5kKG51bGwsIG9wdGlvbnMgYXMgQm9vdHN0cmFwcGVkU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMpLFxuICAgIG1vdW50OiBtb3VudC5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgIHVubW91bnQ6IHVubW91bnQuYmluZChudWxsLCBvcHRpb25zIGFzIEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zKSxcbiAgICB1cGRhdGU6IG9wdGlvbnMudXBkYXRlRnVuY3Rpb24sXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGJvb3RzdHJhcChvcHRpb25zOiBCb290c3RyYXBwZWRTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucywgcHJvcHM6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBBbmd1bGFyIHByb3ZpZGVzIGFuIG9wcG9ydHVuaXR5IHRvIGRldmVsb3AgYHpvbmUtbGVzc2AgYXBwbGljYXRpb24sIHdoZXJlIGRldmVsb3BlcnNcbiAgLy8gaGF2ZSB0byB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gbWFudWFsbHkuXG4gIC8vIFNlZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvem9uZSNub29wem9uZVxuICBpZiAob3B0aW9ucy5OZ1pvbmUgPT09ICdub29wJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEluIG9yZGVyIGZvciBtdWx0aXBsZSBBbmd1bGFyIGFwcHMgdG8gd29yayBjb25jdXJyZW50bHkgb24gYSBwYWdlLCB0aGV5IGVhY2ggbmVlZCBhIHVuaXF1ZSBpZGVudGlmaWVyLlxuICBvcHRpb25zLnpvbmVJZGVudGlmaWVyID0gYHNpbmdsZS1zcGEtYW5ndWxhcjoke3Byb3BzLm5hbWUgfHwgcHJvcHMuYXBwTmFtZX1gO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrLCBzaW5jZSBOZ1pvbmUgZG9lc24ndCBhbGxvdyB5b3UgdG8gY29uZmlndXJlIHRoZSBwcm9wZXJ0eSB0aGF0IGlkZW50aWZpZXMgeW91ciB6b25lLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1BsYWNlTWUtU0FTL3NpbmdsZS1zcGEtYW5ndWxhci1jbGkvaXNzdWVzLzMzLFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZ2xlLXNwYS9zaW5nbGUtc3BhLWFuZ3VsYXIvaXNzdWVzLzQ3LFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvYTE0ZGMyZDdhNDgyMWExOWYyMGE5NTQ3MDUzYTU3MzQ3OThmNTQxZS9wYWNrYWdlcy9jb3JlL3NyYy96b25lL25nX3pvbmUudHMjTDE0NCxcbiAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9hMTRkYzJkN2E0ODIxYTE5ZjIwYTk1NDcwNTNhNTczNDc5OGY1NDFlL3BhY2thZ2VzL2NvcmUvc3JjL3pvbmUvbmdfem9uZS50cyNMMjU3XG4gIG9wdGlvbnMuTmdab25lLmlzSW5Bbmd1bGFyWm9uZSA9ICgpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHdpbmRvdy5ab25lLmN1cnJlbnQuX3Byb3BlcnRpZXNbb3B0aW9ucy56b25lSWRlbnRpZmllcl0gPT09IHRydWU7XG4gIH07XG5cbiAgb3B0aW9ucy5yb3V0aW5nRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICBvcHRpb25zLmJvb3RzdHJhcHBlZE5nWm9uZSEucnVuKCgpID0+IHtcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc2luZ2xlLXNwYS9zaW5nbGUtc3BhLWFuZ3VsYXIvaXNzdWVzLzg2XG4gICAgICAvLyBab25lIGlzIHVuYXdhcmUgb2YgdGhlIHNpbmdsZS1zcGEgbmF2aWdhdGlvbiBjaGFuZ2UgYW5kIHNvIEFuZ3VsYXIgY2hhbmdlIGRldGVjdGlvbiBkb2Vzbid0IHdvcmtcbiAgICAgIC8vIHVubGVzcyB3ZSB0ZWxsIFpvbmUgdGhhdCBzb21ldGhpbmcgaGFwcGVuZWRcbiAgICB9KTtcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbW91bnQob3B0aW9uczogU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMsIHByb3BzOiBhbnkpOiBQcm9taXNlPE5nTW9kdWxlUmVmPGFueT4+IHtcbiAgZ2V0Q29udGFpbmVyRWxlbWVudEFuZFNldFRlbXBsYXRlKG9wdGlvbnMsIHByb3BzKTtcblxuICBjb25zdCBib290c3RyYXBQcm9taXNlID0gb3B0aW9ucy5ib290c3RyYXBGdW5jdGlvbihwcm9wcyk7XG5cbiAgaWYgKE5HX0RFVl9NT0RFICYmICEoYm9vdHN0cmFwUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBgc2luZ2xlLXNwYS1hbmd1bGFyOiB0aGUgb3B0aW9ucy5ib290c3RyYXBGdW5jdGlvbiBtdXN0IHJldHVybiBhIHByb21pc2UsIGJ1dCBpbnN0ZWFkIHJldHVybmVkIGEgJyR7dHlwZW9mIGJvb3RzdHJhcFByb21pc2V9JyB0aGF0IGlzIG5vdCBhIFByb21pc2VgLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBtb2R1bGU6IE5nTW9kdWxlUmVmPGFueT4gPSBhd2FpdCBib290c3RyYXBQcm9taXNlO1xuXG4gIGlmIChOR19ERVZfTU9ERSkge1xuICAgIGlmICghbW9kdWxlIHx8IHR5cGVvZiBtb2R1bGUuZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBzaW5nbGUtc3BhLWFuZ3VsYXI6IHRoZSBvcHRpb25zLmJvb3RzdHJhcEZ1bmN0aW9uIHJldHVybmVkIGEgcHJvbWlzZSB0aGF0IGRpZCBub3QgcmVzb2x2ZSB3aXRoIGEgdmFsaWQgQW5ndWxhciBtb2R1bGUuIERpZCB5b3UgY2FsbCBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKCkgY29ycmVjdGx5P2AsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb246IFNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24gfCBudWxsID0gbW9kdWxlLmluamVjdG9yLmdldChcbiAgICBTaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uLFxuICAgIG51bGwsXG4gICk7XG5cbiAgY29uc3Qgbmdab25lRW5hYmxlZCA9IG9wdGlvbnMuTmdab25lICE9PSAnbm9vcCc7XG5cbiAgLy8gVGhlIHVzZXIgaGFzIHRvIHByb3ZpZGUgYEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uYCBvbmx5IGlmIGhpcyBhcHBsaWNhdGlvbiB1c2VzIHJvdXRpbmcuXG4gIC8vIFNvIGlmIGhlIHByb3ZpZGVkIGBSb3V0ZXJgIGJ1dCBkaWRuJ3QgcHJvdmlkZSBgQnJvd3NlclBsYXRmb3JtTG9jYXRpb25gIHRoZW4gd2UgaGF2ZSB0byBpbmZvcm0gaGltLlxuICAvLyBBbHNvIGBnZXRTaW5nbGVTcGFFeHRyYVByb3ZpZGVycygpYCBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaWYgdGhlIHVzZXIgZG9lc24ndCB1c2VcbiAgLy8gYHpvbmUtbGVzc2AgY2hhbmdlIGRldGVjdGlvbiwgaWYgYE5nWm9uZWAgaXMgYG5vb3BgIHRoZW4gd2UgY2FuIHNraXAgaXQuXG4gIGlmIChOR19ERVZfTU9ERSAmJiBuZ1pvbmVFbmFibGVkICYmIG9wdGlvbnMuUm91dGVyICYmIHNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24gPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgc2luZ2xlLXNwYS1hbmd1bGFyOiBjb3VsZCBub3QgcmV0cmlldmUgZXh0cmEgcHJvdmlkZXJzIGZyb20gdGhlIHBsYXRmb3JtIGluamVjdG9yLiBEaWQgeW91IGNhbGwgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyhnZXRTaW5nbGVTcGFFeHRyYVByb3ZpZGVycygpKS5ib290c3RyYXBNb2R1bGUoKT9cbiAgICBgKTtcbiAgfVxuXG4gIGNvbnN0IGJvb3RzdHJhcHBlZE9wdGlvbnMgPSBvcHRpb25zIGFzIEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zO1xuXG4gIGlmIChuZ1pvbmVFbmFibGVkKSB7XG4gICAgY29uc3Qgbmdab25lOiBOZ1pvbmUgPSBtb2R1bGUuaW5qZWN0b3IuZ2V0KG9wdGlvbnMuTmdab25lKTtcbiAgICBjb25zdCB6b25lSWRlbnRpZmllcjogc3RyaW5nID0gYm9vdHN0cmFwcGVkT3B0aW9ucy56b25lSWRlbnRpZmllciE7XG5cbiAgICAvLyBgTmdab25lYCBjYW4gYmUgZW5hYmxlZCBidXQgcm91dGluZyBtYXkgbm90IGJlIHVzZWQgdGh1cyBgZ2V0U2luZ2xlU3BhRXh0cmFQcm92aWRlcnMoKWBcbiAgICAvLyBmdW5jdGlvbiB3YXMgbm90IGNhbGxlZC5cbiAgICBpZiAoc2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgc2tpcExvY2F0aW9uQ2hhbmdlT25Ob25JbXBlcmF0aXZlUm91dGluZ1RyaWdnZXJzKG1vZHVsZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgYm9vdHN0cmFwcGVkT3B0aW9ucy5ib290c3RyYXBwZWROZ1pvbmUgPSBuZ1pvbmU7XG4gICAgYm9vdHN0cmFwcGVkT3B0aW9ucy5ib290c3RyYXBwZWROZ1pvbmVbJ19pbm5lciddLl9wcm9wZXJ0aWVzW3pvbmVJZGVudGlmaWVyXSA9IHRydWU7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3NpbmdsZS1zcGE6cm91dGluZy1ldmVudCcsIGJvb3RzdHJhcHBlZE9wdGlvbnMucm91dGluZ0V2ZW50TGlzdGVuZXIhKTtcbiAgfVxuXG4gIGJvb3RzdHJhcHBlZE9wdGlvbnMuYm9vdHN0cmFwcGVkTW9kdWxlID0gbW9kdWxlO1xuICByZXR1cm4gbW9kdWxlO1xufVxuXG5mdW5jdGlvbiB1bm1vdW50KG9wdGlvbnM6IEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAob3B0aW9ucy5yb3V0aW5nRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NpbmdsZS1zcGE6cm91dGluZy1ldmVudCcsIG9wdGlvbnMucm91dGluZ0V2ZW50TGlzdGVuZXIpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYm9vdHN0cmFwcGVkTW9kdWxlIS5kZXN0cm95KCk7XG4gICAgb3B0aW9ucy5ib290c3RyYXBwZWRNb2R1bGUgPSBudWxsO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2tpcExvY2F0aW9uQ2hhbmdlT25Ob25JbXBlcmF0aXZlUm91dGluZ1RyaWdnZXJzKFxuICBtb2R1bGU6IE5nTW9kdWxlUmVmPGFueT4sXG4gIG9wdGlvbnM6IFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zLFxuKTogdm9pZCB7XG4gIGlmICghb3B0aW9ucy5OYXZpZ2F0aW9uU3RhcnQpIHtcbiAgICAvLyBBcyBkaXNjdXNzZWQgd2UgZG9uJ3QgZG8gYW55dGhpbmcgcmlnaHQgbm93IGlmIHRoZSBkZXZlbG9wZXIgZG9lc24ndCBwcm92aWRlXG4gICAgLy8gYG9wdGlvbnMuTmF2aWdhdGlvblN0YXJ0YCBzaW5jZSB0aGlzIG1pZ2h0IGJlIGEgYnJlYWtpbmcgY2hhbmdlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJvdXRlciA9IG1vZHVsZS5pbmplY3Rvci5nZXQob3B0aW9ucy5Sb3V0ZXIpO1xuICBjb25zdCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiA9IHJvdXRlci5ldmVudHMuc3Vic2NyaWJlKChldmVudDogYW55KSA9PiB7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2Ygb3B0aW9ucy5OYXZpZ2F0aW9uU3RhcnQhKSB7XG4gICAgICBjb25zdCBjdXJyZW50TmF2aWdhdGlvbiA9IHJvdXRlci5nZXRDdXJyZW50TmF2aWdhdGlvbigpO1xuICAgICAgLy8gVGhpcyBsaXN0ZW5lciB3aWxsIGJlIHNldCB1cCBmb3IgZWFjaCBBbmd1bGFyIGFwcGxpY2F0aW9uXG4gICAgICAvLyB0aGF0IGhhcyByb3V0aW5nIGNhcGFiaWxpdGllcy5cbiAgICAgIC8vIFdlIHNldCBgc2tpcExvY2F0aW9uQ2hhbmdlYCBmb3IgZWFjaCBub24taW1wZXJhdGl2ZSBuYXZpZ2F0aW9uLFxuICAgICAgLy8gQW5ndWxhciByb3V0ZXIgY2hlY2tzIHVuZGVyIHRoZSBob29kIGlmIGl0IGhhcyB0byBjaGFuZ2VcbiAgICAgIC8vIHRoZSBicm93c2VyIFVSTCBvciBub3QuXG4gICAgICAvLyBJZiBgc2tpcExvY2F0aW9uQ2hhbmdlYCBpcyB0cnV0aHkgdGhlbiBBbmd1bGFyIHJvdXRlciB3aWxsIG5vdCBjYWxsXG4gICAgICAvLyBgc2V0QnJvd3NlclVybCgpYCB3aGljaCBjYWxscyBgaGlzdG9yeS5yZXBsYWNlU3RhdGUoKWAgYW5kIGRpc3BhdGNoZXMgYHBvcHN0YXRlYCBldmVudC5cbiAgICAgIGlmIChjdXJyZW50TmF2aWdhdGlvbi50cmlnZ2VyICE9PSAnaW1wZXJhdGl2ZScpIHtcbiAgICAgICAgY3VycmVudE5hdmlnYXRpb24uZXh0cmFzLnNraXBMb2NhdGlvbkNoYW5nZSA9IHRydWU7XG4gICAgICAgIGN1cnJlbnROYXZpZ2F0aW9uLmV4dHJhcy5yZXBsYWNlVXJsID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBtb2R1bGUub25EZXN0cm95KCgpID0+IHtcbiAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfSk7XG59XG4iXX0=